@page "/"
@inject AuthState Auth 
@inject NavigationManager Navigation
@inject IUiStatus UI
@inject ApiClient Api
@inject ITokenStore Tokens

<PageTitle>Home</PageTitle>

<h1>Oautentiserad vy - logga in nedan</h1>

<!-- DESIGN-VAL: Endast e-post + lösenord. Roller kommer från servern efter lyckad inloggning. -->
<EditForm Model="input" OnValidSubmit="Login" FormName="login">
    <div class="mb-2">
        <label>Namn</label>
        <InputText @bind-Value="input.Email" />
    </div>
    <div class="mb-2">
        <label>Lösenord</label>
        <InputText @bind-Value="input.Password" type="password" />
    </div>
    <button>Logga in</button>
</EditForm>

<p class="mt-3">
    <em>Demo‑konton:</em> <code>admin@example.com</code>, <code>teacher@example.com</code>,
    <code>student@example.com</code> (lösen: <code>Pass123!</code>)
</p>

@code {

    Input input = new() { Email = "teacher@example.com", Password = "Pass123!" };

    async Task Login()
    {
        UI.Busy(true);

        try
        {
            // FEL (code‑along): Vi tog roll från UI‑input.
            //   Auth.SignIn(input.Role, input.Name);
            //
            // FIX: Be servern autentisera och ge tillbaka token + alla roller.
            var res = await Api.LoginAsync(input.Email, input.Password);

            // RÄTT: Token lagras i ITokenStore → JwtMessageHandler sätter Authorization‑header automatiskt.
            Tokens.SetToken(res.Token);

			// FEL: Vi tog roll från UI‑input, vilket är osäkert och inte speglar verkligheten.
			// Auth.SignIn(input.Role, input.Name);

            // RÄTT: Signa in med uppgifter från servern (Email + alla roller).
            Auth.SignIn(preferredName: res.Email, roles: res.Roles);

            Navigation.NavigateTo("/library");
        }
        catch(ApiProblemException ex)
        {
            UI.SetError(new UiError("Inloggningen misslyckades", ex.Message));
        }
        finally
        {
            UI.Busy(false);
        }
    }

	// Eftersom vi har valt att Seeda användare i servern, så behöver vi inte roll i input. 
    // Den kommer från servern efter lyckad inloggning.
	// FIX: Ta bort Role från Input-klassen och uppdatera Login-metoden så att den inte längre 
    // använder input.Role.
	// DESIGN-VAL: För enkelhetens skull har vi inte en separat Register-sida, utan använder 
    // Seeding för att skapa demo-konton. I en riktig app skulle vi behöva en mer komplett 
    // auth-lösning med både register och login, och då skulle det vara mer relevant att ha 
    // roll i input.
    public class Input
    {
        public string Email { get; set; } = "";
        public string Password { get; set; } = "";
    }
}

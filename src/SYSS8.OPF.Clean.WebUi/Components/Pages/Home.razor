@page "/"
@inject ApiClient Api
@inject ITokenStore Tokens
@inject AuthState Auth
@inject NavigationManager Nav
@inject IUiStatus UI

<PageTitle>Logga in</PageTitle>
<h1>Logga in</h1>

<!-- DESIGN-VAL: UI anger bara e-post/lösenord, rollen kommer från servern efter login. -->
<EditForm Model="_input" OnValidSubmit="Login">
    <div class="mb-2">
        <label>E‑post</label>
        <InputText @bind-Value="_input.Email" />
    </div>
    <div class="mb-2">
        <label>Lösenord</label>
        <InputText @bind-Value="_input.Password" type="password" />
    </div>
    <button>Logga in</button>
</EditForm>

<p class="mt-3">
    <em>Demo‑konton:</em> <code>admin@example.com</code>, <code>teacher@example.com</code>,
    <code>student@example.com</code> (lösen: <code>Password1!</code>)
</p>

@code {
    Input _input = new() { Email = "teacher@example.com", Password = "Password1!" };

    async Task Login()
    {
        try
        {
            UI.Busy(true);
            // INFO: UI ska inte gissa roll – API:t returnerar Role efter validering.
            var res = await Api.LoginAsync(_input.Email, _input.Password);
            // DESIGN-VAL: Token lagras i TokenStore så HttpClient kan återanvända den i handlers.
            Tokens.SetToken(res.Token);
            Auth.SignIn(res.Role, res.Email);
            // TIPS: Navigation efter login gör att studenten direkt ser auth-skyddad vy.
            Nav.NavigateTo("/library", forceLoad: false);
        }
        catch (ApiProblemException ex)
        {
            UI.SetError(new UiError("Inloggning misslyckades", ex.Message));
        }
        finally
        {
            UI.Busy(false);
        }
    }

    public class Input
    {
        public string Email { get; set; } = "";
        public string Password { get; set; } = "";
    }
}